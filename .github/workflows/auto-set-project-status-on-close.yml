name: Auto Set Project Status to Done on Close

on:
  issues:
    types:
      - closed
  pull_request:
    types:
      - closed
      - merged

jobs:
  update-project-status:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: read # Changed to read, write not strictly needed for this workflow
      pull-requests: read # Changed to read, write not strictly needed for this workflow
      # No 'projects: write' here, relying on PAT scopes as discussed

    steps:
      - name: Get Issue/PR Node ID, Repo Info, and Project ID
        id: get_initial_ids # Renamed ID for clarity
        env:
          ORG_NAME: HisQu
          PROJECT_TITLE: HisQu
          GITHUB_TOKEN: ${{ secrets.ORG_SYNC_PAT }}
        run: |
          ITEM_CONTENT_ID="" # This will store the global ID of the Issue/PR
          REPO_NAME=""
          REPO_OWNER=""

          if [[ "${{ github.event_name }}" == "issues" ]]; then
            ITEM_CONTENT_ID="${{ github.event.issue.node_id }}"
            REPO_NAME="${{ github.event.repository.name }}"
            REPO_OWNER="${{ github.event.repository.owner.login }}"
            echo "Processing issue: ${{ github.event.issue.html_url }}"
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            ITEM_CONTENT_ID="${{ github.event.pull_request.node_id }}"
            REPO_NAME="${{ github.event.repository.name }}"
            REPO_OWNER="${{ github.event.repository.owner.login }}"
            echo "Processing pull request: ${{ github.event.pull_request.html_url }}"
          fi

          echo "ITEM_CONTENT_ID=$ITEM_CONTENT_ID" >> $GITHUB_OUTPUT
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "REPO_OWNER=$REPO_OWNER" >> $GITHUB_OUTPUT

          PROJECT_RESPONSE=$(curl -s -L \
            -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            https://api.github.com/graphql \
            -d '{
              "query": "query($org: String!, $projectTitle: String!) { organization(login: $org) { projectsV2(query: $projectTitle, first: 1) { nodes { id title } } } }",
              "variables": {
                "org": "'"$ORG_NAME"'",
                "projectTitle": "'"$PROJECT_TITLE"'"
              }
            }')

          PROJECT_ID=$(echo "$PROJECT_RESPONSE" | jq -r '.data.organization.projectsV2.nodes[0].id')
          if [ "$PROJECT_ID" == "null" ]; then
            echo "Error: Project with title '$PROJECT_TITLE' not found in organization '$ORG_NAME'."
            exit 1
          fi
          echo "PROJECT_ID=$PROJECT_ID" >> $GITHUB_OUTPUT
          echo "Found Project ID: $PROJECT_ID"

      # --- STEP TO GET THE PROJECT ITEM ID ---
      - name: Get Project V2 Item ID for the Issue/PR
        id: get_project_item_id
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_SYNC_PAT }}
          PROJECT_ID: ${{ steps.get_initial_ids.outputs.PROJECT_ID }}
          ITEM_CONTENT_ID: ${{ steps.get_initial_ids.outputs.ITEM_CONTENT_ID }}
          # We need REPO_OWNER and REPO_NAME for precise matching if issues can have same numbers in different repos
          REPO_OWNER: ${{ steps.get_initial_ids.outputs.REPO_OWNER }}
          REPO_NAME: ${{ steps.get_initial_ids.outputs.REPO_NAME }}
        run: |
          echo "Attempting to find project item for content (Issue/PR) ID: $ITEM_CONTENT_ID in project ID: $PROJECT_ID"
          echo "Target repository: $REPO_OWNER/$REPO_NAME"

          PROJECT_ITEM_ID=""
          HAS_NEXT_PAGE="true" # Start by assuming there's a page
          CURSOR="null"        # GraphQL null, not the string "null" for the first request's variable
          REPO_FULL_NAME="$REPO_OWNER/$REPO_NAME"

          LOOP_COUNT=0
          # Max 15 pages for up to 1500 items (100 items/page). Adjust if your project can be larger.
          MAX_LOOPS=15 

          while [ -z "$PROJECT_ITEM_ID" ] && [ "$HAS_NEXT_PAGE" == "true" ] && [ "$LOOP_COUNT" -lt "$MAX_LOOPS" ]; do
            LOOP_COUNT=$((LOOP_COUNT + 1))
            echo "Fetching project items page: $LOOP_COUNT, Current cursor: $CURSOR"

            # Prepare cursor string for insertion into query.
            # If CURSOR is the literal string "null" (meaning first page), CURSOR_GQL_ARG should be empty.
            # Otherwise, it should be "after: \"$CURSOR\"".
            if [ "$CURSOR" == "null" ]; then
              CURSOR_GQL_ARG=""
            else
              CURSOR_GQL_ARG="after: \"$CURSOR\""
            fi

            GRAPHQL_QUERY_TEMPLATE='
            query($projectId: ID!, $pageCursor: String) { # Use $pageCursor for the 'after' argument
              node(id: $projectId) {
                ... on ProjectV2 {
                  title
                  items(first: 100, %CURSOR_PLACEHOLDER% orderBy: {field: POSITION, direction: ASC}) {
                    pageInfo {
                      hasNextPage
                      endCursor
                    }
                    nodes {
                      id # ProjectV2Item ID
                      content {
                        __typename # Important for knowing the type of content
                        ... on Issue { id repository { fullName:nameWithOwner } } # Alias to fullName for easier access
                        ... on PullRequest { id repository { fullName:nameWithOwner } }
                        # Add ... on DraftIssue { title } if you use draft issues and need to match them
                      }
                    }
                  }
                }
              }
            }'
            # Replace placeholder with the actual cursor argument string
            GRAPHQL_QUERY="${GRAPHQL_QUERY_TEMPLATE//%CURSOR_PLACEHOLDER%/$CURSOR_GQL_ARG}"
            
            # Variables for the GraphQL query.
            # The $pageCursor variable in GraphQL should be 'String', which can accept 'null'.
            VARIABLES_JSON=$(jq -n \
              --arg projectId "$PROJECT_ID" \
              --argjson pageCursor "$([ "$CURSOR" == "null" ] && echo null || echo "\"$CURSOR\"")" \
              '{ "projectId": $projectId, "pageCursor": $pageCursor }')

            JSON_PAYLOAD=$(jq -n --arg query "$GRAPHQL_QUERY" --argjson variables "$VARIABLES_JSON" \
              '{ query: $query, variables: $variables }')

            # echo "DEBUG: JSON Payload for page $LOOP_COUNT:"
            # echo "$JSON_PAYLOAD" # Uncomment for deep debugging

            RESPONSE=$(curl -s -L \
              -X POST \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer $GITHUB_TOKEN" \
              -H "Content-Type: application/json" \
              https://api.github.com/graphql \
              -d "$JSON_PAYLOAD")
            
            # echo "DEBUG: GraphQL Response for page $LOOP_COUNT:"
            # echo "$RESPONSE" # Uncomment for deep debugging

            if echo "$RESPONSE" | jq -e '.errors' > /dev/null; then
              echo "Error: GraphQL query failed on page $LOOP_COUNT:"
              echo "$RESPONSE" | jq '.errors'
              PROJECT_ITEM_ID="ERROR_GRAPHQL_PAGINATION" # Mark error
              HAS_NEXT_PAGE="false" # Stop loop
              continue
            fi

            # Extract pageInfo. Ensure paths are correct and handle nulls.
            CURRENT_PAGE_HAS_NEXT=$(echo "$RESPONSE" | jq -r '.data.node.items.pageInfo.hasNextPage // "false"')
            NEW_CURSOR_RAW=$(echo "$RESPONSE" | jq -r '.data.node.items.pageInfo.endCursor // "null"')

            HAS_NEXT_PAGE="$CURRENT_PAGE_HAS_NEXT"
            if [ "$NEW_CURSOR_RAW" != "null" ] && [ -n "$NEW_CURSOR_RAW" ]; then
              CURSOR="$NEW_CURSOR_RAW"
            else
              CURSOR="null" # Set to string "null" if endCursor is actually null or empty
            fi
            
            # Iterate over nodes in the current page using jq to find the match
            # This is more efficient than a shell loop over many items.
            FOUND_ON_PAGE=$(echo "$RESPONSE" | jq -r \
              --arg targetContentId "$ITEM_CONTENT_ID" \
              --arg targetRepoFullName "$REPO_FULL_NAME" \
              '.data.node.items.nodes[]? | 
               select(
                 .content != null and 
                 .content.id == $targetContentId and 
                 (
                   (.content.__typename == "Issue" or .content.__typename == "PullRequest") and 
                   .content.repository.fullName == $targetRepoFullName
                 )
                 # Example for DraftIssue if you wanted to match by title:
                 # or (.content.__typename == "DraftIssue" and .content.title == "Your Draft Title")
               ) | .id // empty')

            if [ -n "$FOUND_ON_PAGE" ]; then
              PROJECT_ITEM_ID="$FOUND_ON_PAGE"
              PROJECT_TITLE_FROM_RESPONSE=$(echo "$RESPONSE" | jq -r '.data.node.title // "Project (title not in this response page)"')
              echo "Found ProjectV2Item ID: $PROJECT_ITEM_ID on page $LOOP_COUNT for Content ID $ITEM_CONTENT_ID in Project '$PROJECT_TITLE_FROM_RESPONSE'"
              # No need to change HAS_NEXT_PAGE, outer loop condition -z "$PROJECT_ITEM_ID" will handle it
            elif [ "$HAS_NEXT_PAGE" == "false" ]; then
              echo "Item not found on this page, and no more pages. (Page $LOOP_COUNT)"
            else
              echo "Item not found on page $LOOP_COUNT, proceeding to next page."
            fi
          done # End of while loop

          if [ "$PROJECT_ITEM_ID" == "ERROR_GRAPHQL_PAGINATION" ]; then
            echo "Critical Error: GraphQL query failed during pagination. Cannot determine ProjectV2Item ID."
            exit 1
          elif [ -z "$PROJECT_ITEM_ID" ]; then
            if [ "$LOOP_COUNT" -ge "$MAX_LOOPS" ]; then
              echo "Warning: Reached max loop iteration ($MAX_LOOPS pages, approx. $($MAX_LOOPS*100) items) for finding item."
            else
              echo "Warning: Scanned all available pages of the project."
            fi
            echo "Item with Content ID '$ITEM_CONTENT_ID' from repo '$REPO_FULL_NAME' was NOT found in the project."
            echo "Please ensure the issue/PR is correctly added to the project."
            exit 0 # Gracefully exit if item not found after checking all relevant pages
          fi

          echo "PROJECT_ITEM_ID=$PROJECT_ITEM_ID" >> $GITHUB_OUTPUT

      - name: Get Project Status Field ID and Option ID for "Done"
        id: get_field_ids
        env:
          GITHUB_TOKEN: ${{ secrets.ORG_SYNC_PAT }}
          PROJECT_ID: ${{ steps.get_initial_ids.outputs.PROJECT_ID }}
        run: |
          # ... (rest of this step - no change)
          FIELD_RESPONSE=$(curl -s -L \
            -X POST \
            -H "Accept: application/vnd.github.v3+json" \
            -H "Authorization: Bearer $GITHUB_TOKEN" \
            -H "Content-Type: application/json" \
            https://api.github.com/graphql \
            -d '{
              "query": "query($projectId: ID!) { node(id: $projectId) { ... on ProjectV2 { fields(first: 20) { nodes { ... on ProjectV2Field { id name } ... on ProjectV2SingleSelectField { id name options { id name } } } } } } }",
              "variables": {
                "projectId": "'"$PROJECT_ID"'"
              }
            }')

          STATUS_FIELD_ID=$(echo "$FIELD_RESPONSE" | jq -r '.data.node.fields.nodes[] | select(.name == "Status") | .id')
          DONE_OPTION_ID=$(echo "$FIELD_RESPONSE" | jq -r '.data.node.fields.nodes[] | select(.name == "Status") | .options[] | select(.name == "Done") | .id')

          if [ "$STATUS_FIELD_ID" == "null" ]; then
            echo "Error: 'Status' field not found in project."
            exit 1
          fi
          if [ "$DONE_OPTION_ID" == "null" ]; then
            echo "Error: 'Done' option not found in 'Status' field."
            exit 1
          fi

          echo "STATUS_FIELD_ID=$STATUS_FIELD_ID" >> $GITHUB_OUTPUT
          echo "DONE_OPTION_ID=$DONE_OPTION_ID" >> $GITHUB_OUTPUT
          echo "Found Status Field ID: $STATUS_FIELD_ID, Done Option ID: $DONE_OPTION_ID"

      - name: Update Project Item Status to "Done"
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ORG_SYNC_PAT }}
          script: |
            const projectId = "${{ steps.get_initial_ids.outputs.PROJECT_ID }}";
            const projectItemId = "${{ steps.get_project_item_id.outputs.PROJECT_ITEM_ID }}"; // <-- USE PROJECT_ITEM_ID HERE
            const statusFieldId = "${{ steps.get_field_ids.outputs.STATUS_FIELD_ID }}";
            const doneOptionId = "${{ steps.get_field_ids.outputs.DONE_OPTION_ID }}";

            if (!projectItemId) { // Check for projectItemId, not itemNodeId
              core.info('Project item ID not found. Skipping status update.');
              return;
            }

            try {
              await github.graphql(`
                mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) { # itemId instead of itemNodeId
                  updateProjectV2ItemFieldValue(input: {
                    projectId: $projectId,
                    itemId: $itemId, # <-- This is the key change here
                    fieldId: $fieldId,
                    value: {
                      singleSelectOptionId: $optionId
                    }
                  }) {
                    projectV2Item {
                      id
                    }
                  }
                }`, {
                projectId: projectId,
                itemId: projectItemId, // <-- Pass the ProjectV2Item's ID
                fieldId: statusFieldId,
                optionId: doneOptionId
              });
              core.info(`Successfully set status of ${{ github.event_name }} to "Done" in project.`);
            } catch (error) {
              // The error message "Could not resolve to a ProjectV2Item with the ID"
              // should now be caught by the new 'get_project_item_id' step's check,
              // or indicate a different issue.
              core.error(`Failed to update status to "Done" for ${{ github.event_name }}: ${error.message}`);
              core.setFailed(`Failed to update status to "Done" for ${{ github.event_name }}: ${error.message}`);
            }
